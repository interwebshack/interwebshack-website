name: Deploy static site to Cloudflare R2 (apex + www)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # --- Required Secrets (set in GitHub: Settings â†’ Secrets and variables â†’ Actions) ---
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN:  ${{ secrets.CLOUDFLARE_API_TOKEN }}   # must allow: R2 Storage Write, DNS Write, Zone Transform/Origin Rules Write
      R2_ACCESS_KEY_ID:      ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY:  ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET:             ${{ secrets.R2_BUCKET }}              # e.g., site-interwebshack-com-<hash>
      R2_CUSTOM_DOMAIN:      "www.interwebshack.com"

      # --- Derived / Configurable ---
      ZONE_NAME: interwebshack.com
      SITE_DIR: site
      INDEX_OBJECT: index.html
      R2_ENDPOINT: https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # If you have a static-site build step, run it and output to $SITE_DIR.
      # - name: Build site
      #   run: <build> && mv dist "$SITE_DIR"

      - name: Sanity check local site folder
        shell: bash
        run: |
          set -euo pipefail

          echo "ðŸ” Verifying site build output exists"
          echo "ðŸ“ SITE_DIR       = $SITE_DIR"
          echo "ðŸ“„ INDEX_OBJECT   = $INDEX_OBJECT"

          if [[ ! -d "$SITE_DIR" ]]; then
            echo "âŒ Expected directory ./$SITE_DIR but it does not exist."
            echo "   This usually means your build step didn't output to the correct folder."
            exit 1
          fi


          if [[ ! -f "$SITE_DIR/$INDEX_OBJECT" ]]; then
            echo "âŒ Expected file ./$SITE_DIR/$INDEX_OBJECT but it was not found."
            echo "   Check your build command and output path."
            exit 1
          fi

          echo "âœ… Site directory and entry file verified"

      # --- Get zone_id for interwebshack.com ---
      - name: Resolve Cloudflare zone_id
        id: zone
        shell: bash
        run: |
          set -euo pipefail

          echo "ðŸ” Fetching Cloudflare Zone ID for: $ZONE_NAME"

          # Make API request
          response=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}")

          # Split body and HTTP status
          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "ðŸ“¡ Cloudflare API HTTP status: $http_status"

          # If Cloudflare returned error
          if [[ "$http_status" -ne 200 ]]; then
            echo "âŒ Error: Cloudflare API returned HTTP $http_status"
            echo "Response body:"
            echo "$body" | jq .
            exit 1
          fi

          success=$(echo "$body" | jq -r '.success')
          if [[ "$success" != "true" ]]; then
            echo "âŒ Cloudflare returned success=false"
            echo "$body" | jq .
            exit 1
          fi

          zone_count=$(echo "$body" | jq '.result | length')
          if [[ "$zone_count" -eq 0 ]]; then
            echo "âŒ No zones found matching: $ZONE_NAME"
            exit 1
          fi

          zone_id=$(echo "$body" | jq -r '.result[0].id')
          zone_name=$(echo "$body" | jq -r '.result[0].name')

          echo "âœ… Found zone: $zone_name"
          echo "ðŸ”‘ Zone ID: $zone_id"

          echo "zone_id=$zone_id" >> "$GITHUB_OUTPUT"

        # Docs: List Zones (get zone_id). 
        # https://developers.cloudflare.com/api/resources/zones/methods/list/

      # --- Ensure R2 bucket exists ---
      - name: Ensure R2 bucket (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "ðŸª£ Ensuring R2 bucket exists"
          echo "ðŸ“‚ Bucket name: $R2_BUCKET"
          echo "ðŸ‘¤ Account: $CLOUDFLARE_ACCOUNT_ID"

          # Attempt to create the bucket
          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${R2_BUCKET}\"}" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "ðŸ“¡ Cloudflare API HTTP status: $http_status"

          # 200 = created, 201 = created (depending on API), 409 = already exists
          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "âœ… Bucket created successfully (or already existed and returned success)"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "â„¹ï¸ Bucket already exists â€” continuing"
            exit 0
          fi

          echo "âŒ Failed to create bucket. Full Cloudflare response:"
          echo "$body" | jq || echo "$body"
          exit 1

        # Docs: Create R2 bucket (API). 
        # https://developers.cloudflare.com/api/resources/r2/subresources/buckets/methods/create/

      # --- Ensure R2 Custom Domain connected (makes bucket public over CDN) ---
      - name: Ensure R2 Custom Domain (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "ðŸŒ Ensuring R2 custom domain is attached to bucket"
          echo "ðŸª£ Bucket: ${R2_BUCKET}"
          echo "ðŸ”— Custom domain: ${R2_CUSTOM_DOMAIN}"
          echo "ðŸ‘¤ Account: ${CLOUDFLARE_ACCOUNT_ID}"
          echo "ðŸ§­ Zone ID: ${{ steps.zone.outputs.zone_id }}"

          payload=$(jq -n \
            --arg domain "${R2_CUSTOM_DOMAIN}" \
            --arg zoneId "${{ steps.zone.outputs.zone_id }}" \
            '{domain: $domain, enabled: true, zoneId: $zoneId}')

          echo "ðŸ“¦ Request payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET}/domains/custom" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "ðŸ“¡ Cloudflare API HTTP status: $http_status"

          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "âœ… Custom domain attached to bucket successfully"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "â„¹ï¸ Custom domain already attached â€” continuing"
            exit 0
          fi

          echo "âŒ Failed to attach custom domain to R2 bucket"
          echo "â€” Response body â€”"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1

      # Docs: Public buckets & custom domains.
      # https://developers.cloudflare.com/r2/buckets/public-buckets/

      # --- Clean existing DNS records for managed hostnames (skip R2-managed) (idempotent & verbose) ---
      - name: Clean DNS records for root + www
        shell: bash
        env:
          ZONE_ID: ${{ steps.zone.outputs.zone_id }}
          MANAGED_HOSTNAMES: "interwebshack.com www.interwebshack.com"
          CF_DRY_RUN: "0"        # 1 = preview only, 0 = actually delete
          ALLOW_CRITICAL: "0"    # 1 = also delete NS/MX (NOT recommended)
        run: |
          set -euo pipefail

          echo "ðŸ§¹ Preparing to clean DNS records in zone: $ZONE_ID"
          echo "ðŸ”§ Managed hostnames: $MANAGED_HOSTNAMES"
          echo "ðŸ§ª Dry run mode: $CF_DRY_RUN (0=delete, 1=preview only)"
          echo "ðŸš« Skip records auto-managed by R2 (CNAME â†’ *.r2.dev)"
          echo "ðŸš¨ Allow critical (MX/NS) deletion: $ALLOW_CRITICAL (0=no, 1=yes)"

          # Normalize ALLOW_CRITICAL into a number for jq (0 or 1)
          allow_critical_num=0
          [[ "${ALLOW_CRITICAL}" == "1" ]] && allow_critical_num=1

          # Helper: determines if a record is R2-managed (CNAME -> *.r2.dev)
          is_r2_managed() {
            # Args: TYPE NAME CONTENT
            local t="$1" n="$2" c="$3"
            if [[ "$t" == "CNAME" && "$c" =~ \.r2\.dev$ ]]; then
              return 0
            fi
            return 1
          }

          # Helper: delete all records for a given name
          delete_for_name() {
            local name="$1"
            echo ""
            echo "ðŸ”Ž Listing existing DNS records for: $name"

            resp=$(curl -sS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?name=${name}&per_page=1000")

            ok=$(echo "$resp" | jq -r '.success')
            if [[ "$ok" != "true" ]]; then
              echo "âŒ Failed to list DNS records for ${name}"
              echo "$resp" | jq . 2>/dev/null || echo "$resp"
              exit 1
            fi

            count=$(echo "$resp" | jq '.result | length')
            echo "ðŸ“ƒ Found ${count} record(s) for ${name}"

            if [[ "$count" -eq 0 ]]; then
              echo "âœ… Nothing to delete for ${name}"
              return 0
            fi

            echo "ðŸ§¾ Current records:"
            echo "$resp" | jq -r '
              .result[] | [.id, .type, .name, (.content|tostring),
                            (if .proxied then "proxied" else "dns-only" end),
                            (."ttl"|tostring)]
              | @tsv
            ' | awk -F'\t' 'BEGIN{printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n","ID","TYPE","NAME","CONTENT","PROXY","TTL")} {printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n",$1,$2,$3,$4,$5,$6)}'

            # Build list of deletable IDs:
            # - exclude NS/MX unless allow_critical_num==1
            # - exclude CNAMEs to *.r2.dev (auto-managed by R2)
            mapfile -t ids < <(
              echo "$resp" | jq --argjson allow_crit ${allow_critical_num} -r '
                .result[]
                | select( ($allow_crit==1) or (.type!="NS" and .type!="MX") )
                | [.id, .type, .name, (.content|tostring)]
                | @tsv
              ' | while IFS=$'\t' read -r id type rname content; do
                    if is_r2_managed "$type" "$rname" "$content"; then
                      echo "ðŸ›¡ï¸  Skipping R2-managed record (will not delete): type=$type name=$rname content=$content" >&2
                      continue
                    fi
                    echo "$id"
                  done
            )

            if [[ "${#ids[@]}" -eq 0 ]]; then
              echo "ðŸ›¡ï¸ No deletable records for ${name} after safety filters."
              return 0
            fi

            echo "ðŸ—‘ï¸  Will delete ${#ids[@]} record(s) for ${name} (excluding R2-managed):"
            for id in "${ids[@]}"; do
              echo "  id=$id"
            done

            if [[ "$CF_DRY_RUN" == "1" ]]; then
              echo "ðŸ§ª Dry run enabled â€” not deleting."
              return 0
            fi

            for id in "${ids[@]}"; do
              echo "âž¡ï¸  Deleting record id=${id} ..."
              del_resp=$(curl -sS -X DELETE \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${id}")

              del_ok=$(echo "$del_resp" | jq -r '.success')
              if [[ "$del_ok" == "true" ]]; then
                echo "   âœ… Deleted id=${id}"
              else
                code=$(echo "$del_resp" | jq -r '.errors[0]?.code // empty')
                if [[ "$code" == "1052" ]]; then
                  echo "   ðŸ›¡ï¸  Skip: Record is auto-managed by Cloudflare (R2). Not deletable via DNS API."
                  continue
                fi
                echo "   âŒ Failed to delete id=${id}"
                echo "$del_resp" | jq . 2>/dev/null || echo "$del_resp"
                exit 1
              fi
            done

            echo "âœ… Completed deletions for ${name}"
          }

          for host in $MANAGED_HOSTNAMES; do
            delete_for_name "$host"
          done

          echo ""
          echo "ðŸ DNS cleanup complete for: $MANAGED_HOSTNAMES"


      # --- Ensure DNS records for apex exist (proxied placeholder) ---
      # âš ï¸ IMPORTANT: WHY WE USE A PLACEHOLDER RECORD
      # Cloudflare will NOT apply Origin Rules unless a DNS record exists.
      # For R2 static hosting (without a Worker or Pages), the DNS record is just a "proxy trigger".
      #
      # âœ… This A-record points to TEST-NET-1 (192.0.2.1) â€” a ROUTABLE-NOWHERE IP.
      # âœ… Traffic NEVER reaches this IP.
      # âœ… Cloudflare proxy intercepts and rewrites to R2 using an Origin Rule.
      # âœ… This record does NOT get replaced later â€” it stays as a placeholder.
      # âš ï¸ Do NOT change it to your server IP â€” R2 has no IP origin.
      #
      # If you don't want placeholders, use a Worker fronting R2 or Cloudflare Pages instead.
      - name: Ensure DNS â€” apex A (proxied placeholder)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"

          echo "ðŸŒ Ensuring DNS record exists for apex domain"
          echo "ðŸ“› Domain: ${ZONE_NAME}"
          echo "ðŸ§­ Zone ID: ${ZONE_ID}"
          echo "âž¡ï¸  Purpose: Placeholder A record (Cloudflare proxies request, Origin Rule sends to R2)"
          echo "ðŸ·ï¸  Placeholder IP: 192.0.2.1 (TEST-NET-1 â€” safe, unused address)"

          payload=$(jq -n \
            --arg type "A" \
            --arg name "${ZONE_NAME}" \
            --arg content "192.0.2.1" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "ðŸ“¦ Payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "ðŸ“¡ HTTP Status: $http_status"

          success=$(echo "$body" | jq -r '.success')

          if [[ "$success" == "true" ]]; then
            echo "âœ… Apex DNS placeholder created (proxy active for Origin Rule â†’ R2)"
            exit 0
          fi

          # Cloudflare error 81057 = record already exists
          if echo "$body" | jq -r '.errors[]?.code // empty' | grep -q "81057"; then
            echo "â„¹ï¸ Placeholder record already exists â€” OK (idempotent)"
            exit 0
          fi

          echo "âŒ Failed to ensure apex placeholder record"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1

      # --- Ensure DNS â€” www CNAME to apex (proxied placeholder) ---
      # If R2 custom-domain already created a www CNAME to *.r2.dev, we KEEP it and skip.
      # Otherwise we ensure www -> CNAME apex (proxied) so Origin Rules can attach.
      - name: Ensure DNS â€” www CNAME (respect R2-managed)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"
          HOST="www"
          FQDN="${HOST}.${ZONE_NAME}"
          TARGET="${ZONE_NAME}"

          echo "ðŸŒ Ensuring DNS CNAME for: ${FQDN}"
          echo "ðŸŽ¯ Desired target: ${TARGET}"
          echo "â›… Desired mode: proxied"
          echo "ðŸ§­ Zone ID: ${ZONE_ID}"

          # 1) Look up existing CNAME(s) for www
          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=CNAME&name=${FQDN}&per_page=1000")

          list_ok=$(echo "$list_resp" | jq -r '.success')
          if [[ "$list_ok" != "true" ]]; then
            echo "âŒ Failed to list existing CNAMEs for ${FQDN}"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            exit 1
          fi

          count=$(echo "$list_resp" | jq '.result | length')
          echo "ðŸ”Ž Existing CNAME count for ${FQDN}: $count"

          if [[ "$count" -gt 0 ]]; then
            # There is at least one CNAME
            # Check if any is R2-managed (content ends with .r2.dev)
            r2_managed=$(echo "$list_resp" | jq -r '.result[]?.content | select(test("\\.r2\\.dev$")) | . ' | wc -l | tr -d ' ')
            if [[ "$r2_managed" -gt 0 ]]; then
              echo "ðŸ›¡ï¸ Found R2-managed CNAME (â†’ *.r2.dev). Keeping it and skipping changes."
              echo "âœ… www already routed by R2 custom-domain. No action needed."
              exit 0
            fi

            # Not R2-managed. See if one already matches apex + proxied=true
            matching=$(echo "$list_resp" | jq --arg tgt "$TARGET" -r '
              .result[] | select(.content == $tgt and .proxied == true) | .id
            ')
            if [[ -n "$matching" ]]; then
              echo "â„¹ï¸ CNAME already points to apex and is proxied (id=$matching)."
              echo "âœ… No change required."
              exit 0
            fi

            # Otherwise, PATCH the first record to desired state
            record_id=$(echo "$list_resp" | jq -r '.result[0].id')
            echo "ðŸ› ï¸ Updating existing CNAME id=${record_id} to target=${TARGET} (proxied=true)"

            patch_payload=$(jq -n \
              --arg type "CNAME" \
              --arg name "${HOST}" \
              --arg content "${TARGET}" \
              --argjson proxied true \
              '{type:$type,name:$name,content:$content,proxied:$proxied}')

            echo "ðŸ“¦ PATCH payload:"
            echo "$patch_payload" | jq .

            patch_resp=$(curl -sS -w "\n%{http_code}" -X PUT \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${record_id}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$patch_payload" || true)

            patch_body=$(echo "$patch_resp" | sed '$d')
            patch_status=$(echo "$patch_resp" | tail -n1)

            echo "ðŸ“¡ PATCH HTTP Status: $patch_status"
            if [[ "$(echo "$patch_body" | jq -r '.success')" == "true" ]]; then
              echo "âœ… Updated www CNAME successfully."
              exit 0
            else
              echo "âŒ Failed to update existing CNAME"
              echo "$patch_body" | jq . 2>/dev/null || echo "$patch_body"
              exit 1
            fi
          fi

          # 2) No existing CNAME: create desired one (unless R2 will manage it)
          echo "ðŸ†• Creating new CNAME: ${FQDN} â†’ ${TARGET} (proxied=true)"

          post_payload=$(jq -n \
            --arg type "CNAME" \
            --arg name "${HOST}" \
            --arg content "${TARGET}" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "ðŸ“¦ POST payload:"
          echo "$post_payload" | jq .

          post_resp=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$post_payload" || true)

          post_body=$(echo "$post_resp" | sed '$d')
          post_status=$(echo "$post_resp" | tail -n1)

          echo "ðŸ“¡ POST HTTP Status: $post_status"
          if [[ "$(echo "$post_body" | jq -r '.success')" == "true" ]]; then
            echo "âœ… Created www CNAME (proxied) successfully."
            exit 0
          fi

          # Handle "already exists" gracefully (race or pre-existing)
          if echo "$post_body" | jq -r '.errors[]?.code // empty' | grep -q "81053"; then
            echo "â„¹ï¸ Record already exists (81053). This is OK; step is idempotent."
            exit 0
          fi

          echo "âŒ Failed to create www CNAME"
          echo "$post_body" | jq . 2>/dev/null || echo "$post_body"
          exit 1
