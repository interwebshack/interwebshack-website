name: Deploy static site to Cloudflare R2 (root + www via R2 + Worker redirect)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

# One deploy at a time (prevents races in DNS / rules / R2 ops)
concurrency:
  group: deploy-prod
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    # Standard GH token perms; CF auth is via CLOUDFLARE_API_TOKEN secret
    permissions:
      contents: read

    env:
      # --- Required Secrets (set in GitHub: Settings ‚Üí Secrets and variables ‚Üí Actions) ---
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN:  ${{ secrets.CLOUDFLARE_API_TOKEN }}   # must allow: R2 Storage Write, DNS Write, Zone Transform/Origin Rules Write
      R2_ACCESS_KEY_ID:      ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY:  ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET:             ${{ secrets.R2_BUCKET }}              # e.g., site-interwebshack-com-<hash>
      R2_CUSTOM_DOMAIN:      "www.interwebshack.com"

      # --- Derived / Configurable ---
      ZONE_NAME: interwebshack.com
      SITE_DIR: site
      INDEX_OBJECT: index.html
      R2_ENDPOINT: https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools (jq, curl, node)
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq
          node --version || true
          npm --version || true

      # If you have a static-site build step, run it and output to $SITE_DIR.
      # - name: Build site
      #   run: <build> && mv dist "$SITE_DIR"

      - name: Sanity check local site folder
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Verifying site build output exists"
          echo "üìÅ SITE_DIR       = $SITE_DIR"
          echo "üìÑ INDEX_OBJECT   = $INDEX_OBJECT"

          if [[ ! -d "$SITE_DIR" ]]; then
            echo "‚ùå Expected directory ./$SITE_DIR but it does not exist."
            echo "   This usually means your build step didn't output to the correct folder."
            exit 1
          fi


          if [[ ! -f "$SITE_DIR/$INDEX_OBJECT" ]]; then
            echo "‚ùå Expected file ./$SITE_DIR/$INDEX_OBJECT but it was not found."
            echo "   Check your build command and output path."
            exit 1
          fi

          echo "‚úÖ Site directory and entry file verified"

      # --- Get zone_id for interwebshack.com ---
      - name: Resolve Cloudflare zone_id
        id: zone
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Fetching Cloudflare Zone ID for: $ZONE_NAME"

          # Make API request
          response=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}")

          # Split body and HTTP status
          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # If Cloudflare returned error
          if [[ "$http_status" -ne 200 ]]; then
            echo "‚ùå Error: Cloudflare API returned HTTP $http_status"
            echo "Response body:"
            echo "$body" | jq .
            exit 1
          fi

          success=$(echo "$body" | jq -r '.success')
          if [[ "$success" != "true" ]]; then
            echo "‚ùå Cloudflare returned success=false"
            echo "$body" | jq .
            exit 1
          fi

          zone_count=$(echo "$body" | jq '.result | length')
          if [[ "$zone_count" -eq 0 ]]; then
            echo "‚ùå No zones found matching: $ZONE_NAME"
            exit 1
          fi

          zone_id=$(echo "$body" | jq -r '.result[0].id')
          zone_name=$(echo "$body" | jq -r '.result[0].name')

          echo "‚úÖ Found zone: $zone_name"
          echo "üîë Zone ID: $zone_id"

          echo "zone_id=$zone_id" >> "$GITHUB_OUTPUT"

        # Docs: List Zones (get zone_id). 
        # https://developers.cloudflare.com/api/resources/zones/methods/list/

      # --- Ensure R2 bucket exists ---
      - name: Ensure R2 bucket (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "ü™£ Ensuring R2 bucket exists"
          echo "üìÇ Bucket name: $R2_BUCKET"
          echo "üë§ Account: $CLOUDFLARE_ACCOUNT_ID"

          # Attempt to create the bucket
          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${R2_BUCKET}\"}" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # 200 = created, 201 = created (depending on API), 409 = already exists
          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Bucket created successfully (or already existed and returned success)"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Bucket already exists ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to create bucket. Full Cloudflare response:"
          echo "$body" | jq || echo "$body"
          exit 1

        # Docs: Create R2 bucket (API). 
        # https://developers.cloudflare.com/api/resources/r2/subresources/buckets/methods/create/

      # --- Ensure R2 Custom Domain connected (makes bucket public over CDN) ---
      - name: Ensure R2 Custom Domain (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "üåê Ensuring R2 custom domain is attached to bucket"
          echo "ü™£ Bucket: ${R2_BUCKET}"
          echo "üîó Custom domain: ${R2_CUSTOM_DOMAIN}"
          echo "üë§ Account: ${CLOUDFLARE_ACCOUNT_ID}"
          echo "üß≠ Zone ID: ${{ steps.zone.outputs.zone_id }}"

          payload=$(jq -n \
            --arg domain "${R2_CUSTOM_DOMAIN}" \
            --arg zoneId "${{ steps.zone.outputs.zone_id }}" \
            '{domain: $domain, enabled: true, zoneId: $zoneId}')

          echo "üì¶ Request payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET}/domains/custom" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Custom domain attached to bucket successfully"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Custom domain already attached ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to attach custom domain to R2 bucket"
          echo "‚Äî Response body ‚Äî"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1

      # Docs: Public buckets & custom domains.
      # https://developers.cloudflare.com/r2/buckets/public-buckets/

      # --- Clean existing DNS records for managed hostnames (skip R2-managed) (idempotent & verbose) ---
      - name: Clean DNS records for root + www
        shell: bash
        env:
          ZONE_ID: ${{ steps.zone.outputs.zone_id }}
          MANAGED_HOSTNAMES: "interwebshack.com www.interwebshack.com"
          CF_DRY_RUN: "0"        # 1 = preview only, 0 = actually delete
          ALLOW_CRITICAL: "0"    # 1 = also delete NS/MX (NOT recommended)
        run: |
          set -euo pipefail

          echo "üßπ Preparing to clean DNS records in zone: $ZONE_ID"
          echo "üîß Managed hostnames: $MANAGED_HOSTNAMES"
          echo "üß™ Dry run mode: $CF_DRY_RUN (0=delete, 1=preview only)"
          echo "üö´ Skip records auto-managed by R2 (CNAME ‚Üí *.r2.dev)"
          echo "üö® Allow critical (MX/NS) deletion: $ALLOW_CRITICAL (0=no, 1=yes)"

          # Normalize ALLOW_CRITICAL into a number for jq (0 or 1)
          allow_critical_num=0
          [[ "${ALLOW_CRITICAL}" == "1" ]] && allow_critical_num=1

          # Helper: determines if a record is R2-managed (CNAME -> *.r2.dev)
          is_r2_managed() {
            # Args: TYPE NAME CONTENT
            local t="$1" n="$2" c="$3"
            if [[ "$t" == "CNAME" && "$c" =~ \.r2\.dev$ ]]; then
              return 0
            fi
            return 1
          }

          # Helper: delete all records for a given name
          delete_for_name() {
            local name="$1"
            echo ""
            echo "üîé Listing existing DNS records for: $name"

            resp=$(curl -sS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?name=${name}&per_page=1000")

            ok=$(echo "$resp" | jq -r '.success')
            if [[ "$ok" != "true" ]]; then
              echo "‚ùå Failed to list DNS records for ${name}"
              echo "$resp" | jq . 2>/dev/null || echo "$resp"
              exit 1
            fi

            count=$(echo "$resp" | jq '.result | length')
            echo "üìÉ Found ${count} record(s) for ${name}"

            if [[ "$count" -eq 0 ]]; then
              echo "‚úÖ Nothing to delete for ${name}"
              return 0
            fi

            echo "üßæ Current records:"
            echo "$resp" | jq -r '
              .result[] | [.id, .type, .name, (.content|tostring),
                            (if .proxied then "proxied" else "dns-only" end),
                            (."ttl"|tostring)]
              | @tsv
            ' | awk -F'\t' 'BEGIN{printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n","ID","TYPE","NAME","CONTENT","PROXY","TTL")} {printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n",$1,$2,$3,$4,$5,$6)}'

            # Build list of deletable IDs:
            # - exclude NS/MX unless allow_critical_num==1
            # - exclude CNAMEs to *.r2.dev (auto-managed by R2)
            mapfile -t ids < <(
              echo "$resp" | jq --argjson allow_crit ${allow_critical_num} -r '
                .result[]
                | select( ($allow_crit==1) or (.type!="NS" and .type!="MX") )
                | [.id, .type, .name, (.content|tostring)]
                | @tsv
              ' | while IFS=$'\t' read -r id type rname content; do
                    if is_r2_managed "$type" "$rname" "$content"; then
                      echo "üõ°Ô∏è  Skipping R2-managed record (will not delete): type=$type name=$rname content=$content" >&2
                      continue
                    fi
                    echo "$id"
                  done
            )

            if [[ "${#ids[@]}" -eq 0 ]]; then
              echo "üõ°Ô∏è No deletable records for ${name} after safety filters."
              return 0
            fi

            echo "üóëÔ∏è  Will delete ${#ids[@]} record(s) for ${name} (excluding R2-managed):"
            for id in "${ids[@]}"; do
              echo "  id=$id"
            done

            if [[ "$CF_DRY_RUN" == "1" ]]; then
              echo "üß™ Dry run enabled ‚Äî not deleting."
              return 0
            fi

            for id in "${ids[@]}"; do
              echo "‚û°Ô∏è  Deleting record id=${id} ..."
              del_resp=$(curl -sS -X DELETE \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${id}")

              del_ok=$(echo "$del_resp" | jq -r '.success')
              if [[ "$del_ok" == "true" ]]; then
                echo "   ‚úÖ Deleted id=${id}"
              else
                code=$(echo "$del_resp" | jq -r '.errors[0]?.code // empty')
                if [[ "$code" == "1052" ]]; then
                  echo "   üõ°Ô∏è  Skip: Record is auto-managed by Cloudflare (R2). Not deletable via DNS API."
                  continue
                fi
                echo "   ‚ùå Failed to delete id=${id}"
                echo "$del_resp" | jq . 2>/dev/null || echo "$del_resp"
                exit 1
              fi
            done

            echo "‚úÖ Completed deletions for ${name}"
          }

          for host in $MANAGED_HOSTNAMES; do
            delete_for_name "$host"
          done

          echo ""
          echo "üèÅ DNS cleanup complete for: $MANAGED_HOSTNAMES"

      # --- Ensure DNS records for apex exist (proxied placeholder) ---
      # ‚ö†Ô∏è IMPORTANT: WHY WE USE A PLACEHOLDER RECORD
      # Cloudflare will NOT apply Origin Rules unless a DNS record exists.
      # For R2 static hosting (without a Worker or Pages), the DNS record is just a "proxy trigger".
      #
      # ‚úÖ This A-record points to TEST-NET-1 (192.0.2.1) ‚Äî a ROUTABLE-NOWHERE IP.
      # ‚úÖ Traffic NEVER reaches this IP.
      # ‚úÖ Cloudflare proxy intercepts and rewrites to R2 using an Origin Rule.
      # ‚úÖ This record does NOT get replaced later ‚Äî it stays as a placeholder.
      # ‚ö†Ô∏è Do NOT change it to your server IP ‚Äî R2 has no IP origin.
      #
      # If you don't want placeholders, use a Worker fronting R2 or Cloudflare Pages instead.
      - name: Ensure DNS ‚Äî apex A (proxied placeholder)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"

          echo "üåê Ensuring DNS record exists for apex domain"
          echo "üìõ Domain: ${ZONE_NAME}"
          echo "üß≠ Zone ID: ${ZONE_ID}"
          echo "‚û°Ô∏è  Purpose: Placeholder A record (Cloudflare proxies request, Origin Rule sends to R2)"
          echo "üè∑Ô∏è  Placeholder IP: 192.0.2.1 (TEST-NET-1 ‚Äî safe, unused address)"

          payload=$(jq -n \
            --arg type "A" \
            --arg name "${ZONE_NAME}" \
            --arg content "192.0.2.1" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "üì¶ Payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° HTTP Status: $http_status"

          success=$(echo "$body" | jq -r '.success')

          if [[ "$success" == "true" ]]; then
            echo "‚úÖ Apex DNS placeholder created (proxy active for Origin Rule ‚Üí R2)"
            exit 0
          fi

          # Cloudflare error 81057 = record already exists
          if echo "$body" | jq -r '.errors[]?.code // empty' | grep -q "81057"; then
            echo "‚ÑπÔ∏è Placeholder record already exists ‚Äî OK (idempotent)"
            exit 0
          fi

          echo "‚ùå Failed to ensure apex placeholder record"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1
        # Docs: Create DNS record. 
        # https://developers.cloudflare.com/api/resources/dns/subresources/records/methods/create/

      # --- (Optional) Ensure DNS ‚Äî www CNAME to apex (proxied placeholder) ------
      # If R2 custom-domain already created CNAME www -> *.r2.dev (proxied), SKIP creating your own www record.
      # We simply respect the R2-managed record. If you want your own www->apex placeholder instead, you can add
      # the idempotent 'respect R2-managed' step we drafted earlier.

      # # --- Upload site to R2 (S3 API; verbose) ---------------------------------
      # - name: Upload site to R2 (S3 API)
      #   if: ${{ env.SITE_DIR != '' }}
      #   shell: bash
      #   env:
      #     AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      #     AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      #     AWS_EC2_METADATA_DISABLED: "true"
      #   run: |
      #     set -euo pipefail
      #     echo "üì§ Syncing $SITE_DIR ‚Üí r2://$R2_BUCKET/"
      #     # Install AWS CLI v2 quickly (or use preinstalled if present)
      #     pipx install awscli || pip install --user awscli || true
      #     aws --version

      #     # Configure S3 endpoint for R2 (path-style is fine here)
      #     aws s3 sync "$SITE_DIR/" "s3://$R2_BUCKET/" \
      #       --endpoint-url "$R2_ENDPOINT" \
      #       --delete

      #     echo "‚úÖ Upload complete."

      # --- Deploy a tiny Worker that redirects the apex ‚Üí www (301) ---
      # Why this instead of Redirect Rules?
      # ‚Ä¢ Works on all plans, no ‚Äúentitlement‚Äù surprises
      # ‚Ä¢ Clear behavior: only apex redirects; www is served by R2 (R2-managed CNAME)
      # ‚Ä¢ Logs + routes are visible in Wrangler output
      - name: Deploy Worker redirect apex ‚Üí www (301)
        shell: bash
        run: |
          set -euo pipefail

          echo "üõ†Ô∏è  Writing Worker source (redirect-apex.js)‚Ä¶"
          cat > redirect-apex.js <<'JS'
export default {
  async fetch(request) {
    const url = new URL(request.url);
    // Redirect ONLY the apex; leave www (and any others) untouched
    if (url.hostname === "interwebshack.com") {
      url.hostname = "www.interwebshack.com";
      return Response.redirect(url.toString(), 301);
    }
    return fetch(request);
  }
};
JS

    echo "üßæ Writing wrangler.toml (route attached at apex)‚Ä¶"
    cat > wrangler.toml <<'TOML'
name = "redirect-apex"
main = "redirect-apex.js"
compatibility_date = "2024-10-01"

routes = [
  { pattern = "interwebshack.com/*", zone_name = "interwebshack.com" }
]
TOML

    echo "üöÄ Deploying with Wrangler (uses CLOUDFLARE_API_TOKEN)‚Ä¶"
    npx --yes wrangler@latest deploy --account-id "${CLOUDFLARE_ACCOUNT_ID}"

    echo "üîé Verifying routes for this Worker‚Ä¶"
    npx --yes wrangler@latest routes list --account-id "${CLOUDFLARE_ACCOUNT_ID}" \
      | sed -n '1,200p'














      # --- Ensure DNS ‚Äî www CNAME to apex (proxied placeholder) ---
      # If R2 custom-domain already created a www CNAME to *.r2.dev, we KEEP it and skip.
      # Otherwise we ensure www -> CNAME apex (proxied) so Origin Rules can attach.
      - name: Ensure DNS ‚Äî www CNAME (respect R2-managed)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"
          HOST="www"
          FQDN="${HOST}.${ZONE_NAME}"
          TARGET="${ZONE_NAME}"

          echo "üåê Ensuring DNS CNAME for: ${FQDN}"
          echo "üéØ Desired target: ${TARGET}"
          echo "‚õÖ Desired mode: proxied"
          echo "üß≠ Zone ID: ${ZONE_ID}"

          # 1) Look up existing CNAME(s) for www
          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=CNAME&name=${FQDN}&per_page=1000")

          list_ok=$(echo "$list_resp" | jq -r '.success')
          if [[ "$list_ok" != "true" ]]; then
            echo "‚ùå Failed to list existing CNAMEs for ${FQDN}"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            exit 1
          fi

          count=$(echo "$list_resp" | jq '.result | length')
          echo "üîé Existing CNAME count for ${FQDN}: $count"

          if [[ "$count" -gt 0 ]]; then
            # There is at least one CNAME
            # Check if any is R2-managed (content ends with .r2.dev)
            r2_managed=$(echo "$list_resp" | jq -r '.result[]?.content | select(test("\\.r2\\.dev$")) | . ' | wc -l | tr -d ' ')
            if [[ "$r2_managed" -gt 0 ]]; then
              echo "üõ°Ô∏è Found R2-managed CNAME (‚Üí *.r2.dev). Keeping it and skipping changes."
              echo "‚úÖ www already routed by R2 custom-domain. No action needed."
              exit 0
            fi

            # Not R2-managed. See if one already matches apex + proxied=true
            matching=$(echo "$list_resp" | jq --arg tgt "$TARGET" -r '
              .result[] | select(.content == $tgt and .proxied == true) | .id
            ')
            if [[ -n "$matching" ]]; then
              echo "‚ÑπÔ∏è CNAME already points to apex and is proxied (id=$matching)."
              echo "‚úÖ No change required."
              exit 0
            fi

            # Otherwise, PATCH the first record to desired state
            record_id=$(echo "$list_resp" | jq -r '.result[0].id')
            echo "üõ†Ô∏è Updating existing CNAME id=${record_id} to target=${TARGET} (proxied=true)"

            patch_payload=$(jq -n \
              --arg type "CNAME" \
              --arg name "${HOST}" \
              --arg content "${TARGET}" \
              --argjson proxied true \
              '{type:$type,name:$name,content:$content,proxied:$proxied}')

            echo "üì¶ PATCH payload:"
            echo "$patch_payload" | jq .

            patch_resp=$(curl -sS -w "\n%{http_code}" -X PUT \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${record_id}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$patch_payload" || true)

            patch_body=$(echo "$patch_resp" | sed '$d')
            patch_status=$(echo "$patch_resp" | tail -n1)

            echo "üì° PATCH HTTP Status: $patch_status"
            if [[ "$(echo "$patch_body" | jq -r '.success')" == "true" ]]; then
              echo "‚úÖ Updated www CNAME successfully."
              exit 0
            else
              echo "‚ùå Failed to update existing CNAME"
              echo "$patch_body" | jq . 2>/dev/null || echo "$patch_body"
              exit 1
            fi
          fi

          # 2) No existing CNAME: create desired one (unless R2 will manage it)
          echo "üÜï Creating new CNAME: ${FQDN} ‚Üí ${TARGET} (proxied=true)"

          post_payload=$(jq -n \
            --arg type "CNAME" \
            --arg name "${HOST}" \
            --arg content "${TARGET}" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "üì¶ POST payload:"
          echo "$post_payload" | jq .

          post_resp=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$post_payload" || true)

          post_body=$(echo "$post_resp" | sed '$d')
          post_status=$(echo "$post_resp" | tail -n1)

          echo "üì° POST HTTP Status: $post_status"
          if [[ "$(echo "$post_body" | jq -r '.success')" == "true" ]]; then
            echo "‚úÖ Created www CNAME (proxied) successfully."
            exit 0
          fi

          # Handle "already exists" gracefully (race or pre-existing)
          if echo "$post_body" | jq -r '.errors[]?.code // empty' | grep -q "81053"; then
            echo "‚ÑπÔ∏è Record already exists (81053). This is OK; step is idempotent."
            exit 0
          fi

          echo "‚ùå Failed to create www CNAME"
          echo "$post_body" | jq . 2>/dev/null || echo "$post_body"
          exit 1
        # Docs: Create DNS record. 
        # https://developers.cloudflare.com/api/resources/dns/subresources/records/methods/create/

      # --- Ensure an Origin Rules ruleset exists; then add rules to route apex + www to R2 ---
      # Cloudflare Engine Logic:
      #   DNS record -> CF Proxy -> Origin Rule -> R2 bucket
      #
      # Why we need this:
      #  ‚Ä¢ R2 buckets have no IP (you can't point DNS directly)
      #  ‚Ä¢ DNS just "activates" the proxy
      #  ‚Ä¢ Origin Rules change the "origin" to the R2 bucket hostname
      #
      # This step ensures the `http_request_origin` phase ruleset exists.
      #   - If it exists, we reuse it (idempotent)
      #   - If it doesn't exist, we create it
      #
      # Phase explanation:
      #   "http_request_origin" phase runs when Cloudflare chooses the origin to fetch from.
      #   It will tell Cloudflare: "instead of placeholder IP, talk to R2"
      #
      - name: Ensure Origin Rules ruleset exists (http_request_origin)
        id: ruleset
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"

          echo "üö¶ Ensuring Origin Rules ruleset exists for zone"
          echo "üß≠ Zone ID: $ZONE_ID"
          echo "üîÅ Purpose: Create or fetch the 'http_request_origin' ruleset (used to route apex+www ‚Üí R2)"

          echo "üîé Checking for existing ruleset in http_request_origin phase..."

          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets")

          list_ok=$(echo "$list_resp" | jq -r '.success // empty')

          if [[ "$list_ok" != "true" ]]; then
            echo "‚ùå Failed to list rulesets"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            exit 1
          fi

          rid=$(echo "$list_resp" | jq -r '.result[] | select(.phase=="http_request_origin") | .id // empty')

          if [[ -n "$rid" ]]; then
            echo "‚úÖ Found existing http_request_origin ruleset"
            echo "üÜî Ruleset ID: $rid"
          else
            echo "‚ö†Ô∏è No existing http_request_origin ruleset found"
            echo "‚ûï Creating new Origin Rules ruleset for this zone..."

            create_payload='{
              "name": "Origin Rules ruleset",
              "description": "Zone-level ruleset for origin overrides (R2 static hosting)",
              "kind": "zone",
              "phase": "http_request_origin",
              "rules": []
            }'

            echo "üì¶ Payload:"
            echo "$create_payload" | jq .

            create_resp=$(curl -sS -X POST \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$create_payload")

            create_ok=$(echo "$create_resp" | jq -r '.success // empty')

            if [[ "$create_ok" != "true" ]]; then
              echo "‚ùå Failed to create Origin Rules ruleset"
              echo "$create_resp" | jq . 2>/dev/null || echo "$create_resp"
              exit 1
            fi

            rid=$(echo "$create_resp" | jq -r '.result.id')
            echo "‚úÖ Created new Origin Rules ruleset"
            echo "üÜî Ruleset ID: $rid"
          fi

          echo "üì§ Exporting ruleset_id to GitHub outputs"
          echo "ruleset_id=$rid" >> "$GITHUB_OUTPUT"

          echo "üèÅ Origin Rules ruleset ensure step complete ‚Äî ruleset is ready."
          echo "   Next step will insert/update rule to route apex + www ‚Üí R2"

      # --- Ensure Account-level Redirect Rules ruleset exists (http_request_redirect) ---
      # WHY ACCOUNT-LEVEL?
      #  ‚Ä¢ Cloudflare's "Redirect Rules" are implemented in the account-level phase: http_request_redirect
      #  ‚Ä¢ Your earlier error ("phase ... not allowed at zone level") confirms this.
      #  ‚Ä¢ We will create/fetch the account-level ruleset and then scope rules to your zone in expressions.
      #
      # PERMISSIONS REQUIRED:
      #  ‚Ä¢ Account ‚Üí Rulesets / Transform Rules: Edit   (UI label varies)
      #
      - name: Ensure Redirect Rules ruleset exists (account-level http_request_redirect)
        id: acct_redirect_ruleset
        shell: bash
        run: |
          set -euo pipefail
          ACCOUNT_ID="${CLOUDFLARE_ACCOUNT_ID}"

          echo "üö¶ Ensuring ACCOUNT-level Redirect Rules ruleset exists"
          echo "üë§ Account ID: ${ACCOUNT_ID}"
          echo "üìå Phase: http_request_redirect (account-level only)"

          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/rulesets")

          if [[ "$(echo "$list_resp" | jq -r '.success')" != "true" ]]; then
            echo "‚ùå Failed to list account rulesets"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            echo "üõ† Fix: Ensure your token has Account ‚Üí Rulesets/Transform Rules: Edit"
            exit 1
          fi

          rid=$(echo "$list_resp" | jq -r '.result[] | select(.phase=="http_request_redirect") | .id // empty')

          if [[ -n "$rid" ]]; then
            echo "‚úÖ Found existing account redirect ruleset: $rid"
          else
            echo "‚ûï Creating account redirect ruleset‚Ä¶"

            create_payload='{
              "name": "Account Redirect Rules",
              "description": "Account-level ruleset for apex‚Üíwww redirect (R2 static hosting)",
              "kind": "root",
              "phase": "http_request_redirect",
              "rules": []
            }'

            echo "üì¶ Payload:"; echo "$create_payload" | jq .

            create_resp=$(curl -sS -X POST \
              "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/rulesets" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$create_payload")

            if [[ "$(echo "$create_resp" | jq -r '.success')" != "true" ]]; then
              echo "‚ùå Failed to create account redirect ruleset"
              echo "$create_resp" | jq . 2>/dev/null || echo "$create_resp"
              exit 1
            fi

            rid=$(echo "$create_resp" | jq -r '.result.id')
            echo "‚úÖ Created account redirect ruleset: $rid"
          fi

          echo "account_redirect_ruleset_id=$rid" >> "$GITHUB_OUTPUT"


        # Docs: Origin Rules via Rulesets API (phase http_request_origin).
        # https://developers.cloudflare.com/rules/origin-rules/create-api/

      # --- Upsert ACCOUNT-level Redirect Rule: interwebshack.com ‚Üí https://www.interwebshack.com (301) ---
      # Why compose the URL in expression?
      # ‚Ä¢ Avoids 'preserve_query_string' field compatibility issues
      # ‚Ä¢ Explicitly keeps both path and query
      # Expression notes:
      # ‚Ä¢ cf.zone.name scopes to this zone only (safe when multiple zones share the account ruleset)
      # ‚Ä¢ http.request.uri.path + http.request.uri.query give us the full request target
      # 
      # WHY ACCOUNT-LEVEL + SCOPED?
      #  ‚Ä¢ Redirect rules live at account level, so this rule must be placed there.
      #  ‚Ä¢ To avoid affecting other zones in the account, we scope the expression with cf.zone.name.
      #
      # FINAL BEHAVIOR:
      #   http://interwebshack.com/*   ‚Üí https://www.interwebshack.com/*
      #   https://interwebshack.com/*  ‚Üí https://www.interwebshack.com/*
      #
      # PERMISSIONS REQUIRED:
      #  ‚Ä¢ Account ‚Üí Rulesets / Transform Rules: Edit
      #
      # --- Upsert ACCOUNT-level Redirect Rule: interwebshack.com ‚Üí https://www.interwebshack.com (301) ---
      # Note: On account-level http_request_redirect, the `redirect` action expects parameters
      # WITHOUT the `from_value` wrapper. We try that first (Variant A), and if the API still
      # complains, we fall back to the older/alternate schema (Variant B) automatically.
      - name: Upsert account-level redirect rule apex ‚Üí www (301)
        shell: bash
        run: |
          set -euo pipefail

          ACCOUNT_ID="${CLOUDFLARE_ACCOUNT_ID}"
          ZONE_NAME="${ZONE_NAME}"
          RSET_ID="${{ steps.acct_redirect_ruleset.outputs.account_redirect_ruleset_id }}"
          WWW_HOST="www.${ZONE_NAME}"

          echo "üîÅ Ensuring account-level redirect for ${ZONE_NAME} ‚Üí ${WWW_HOST}"
          echo "üë§ Account ID: ${ACCOUNT_ID}"
          echo "üÜî Account Redirect Ruleset ID: ${RSET_ID}"

          # Scope to THIS zone only (avoid impacting other domains in the account)
          EXPR="(cf.zone.name eq \"${ZONE_NAME}\") and (http.host eq \"${ZONE_NAME}\")"
          RULE_REF="acct_redirect_apex_to_www"
          RULE_DESC="Account-level redirect apex ‚Üí www (301) for ${ZONE_NAME}"

          # Compose target URL to preserve path+query:
          TARGET_EXPR="concat(\"https://${WWW_HOST}\", http.request.uri.path, if(len(http.request.uri.query) > 0, concat(\"?\", http.request.uri.query), \"\"))"

          # ---------- Variant A (preferred): no `from_value` wrapper ----------
          desired_rule_A=$(jq -n \
            --arg ref  "$RULE_REF" \
            --arg desc "$RULE_DESC" \
            --arg expr "$EXPR" \
            --arg tgt  "$TARGET_EXPR" \
            '{
              ref: $ref,
              description: $desc,
              expression: $expr,
              action: "redirect",
              action_parameters: {
                status_code: 301,
                target_url: { expression: $tgt }
              }
            }')

          # ---------- Variant B (fallback): with `from_value` wrapper ----------
          desired_rule_B=$(jq -n \
            --arg ref  "$RULE_REF" \
            --arg desc "$RULE_DESC" \
            --arg expr "$EXPR" \
            --arg tgt  "$TARGET_EXPR" \
            '{
              ref: $ref,
              description: $desc,
              expression: $expr,
              action: "redirect",
              action_parameters: {
                from_value: {
                  status_code: 301,
                  target_url: { expression: $tgt }
                }
              }
            }')

          echo "üß© Desired redirect rule (Variant A, no from_value):"
          echo "$desired_rule_A" | jq .

          # --- Fetch current account redirect ruleset
          get_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/rulesets/${RSET_ID}")
          if [[ "$(echo "$get_resp" | jq -r '.success')" != "true" ]]; then
            echo "‚ùå Failed to fetch account redirect ruleset"
            echo "$get_resp" | jq . 2>/dev/null || echo "$get_resp"
            exit 1
          fi
          current_rules=$(echo "$get_resp" | jq '.result.rules // []')
          current_count=$(echo "$current_rules" | jq 'length')
          echo "üìö Existing rules in account ruleset: $current_count"

          # Merge: replace same-ref rule, append desired
          build_payload() {
            local desired_json="$1"
            jq --arg ref "$RULE_REF" --argjson desired "$desired_json" -n \
              --argjson current "$current_rules" '
                { rules:
                  (($current | map(select(.ref != $ref))) + [ $desired ])
                }'
          }

          put_with_payload() {
            local payload="$1" label="$2"
            echo "üì¶ PUT payload (${label}):"
            echo "$payload" | jq .

            resp=$(curl -sS -w "\n%{http_code}" -X PUT \
              "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/rulesets/${RSET_ID}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$payload" || true)
            body=$(echo "$resp" | sed '$d'); code=$(echo "$resp" | tail -n1)
            echo "üì° PUT HTTP Status (${label}): $code"
            echo "$body" | jq . 2>/dev/null || echo "$body"
            echo
            if [[ "$(echo "$body" | jq -r '.success // empty')" == "true" ]]; then
              echo "‚úÖ Success with ${label}"
              return 0
            fi
            return 1
          }

          # Try Variant A first
          payload_A=$(build_payload "$desired_rule_A")
          if put_with_payload "$payload_A" "Variant A (no from_value)"; then
            exit 0
          fi

          echo "‚Ü©Ô∏è  Variant A failed. Trying Variant B (with from_value)‚Ä¶"
          payload_B=$(build_payload "$desired_rule_B")
          if put_with_payload "$payload_B" "Variant B (with from_value)"; then
            exit 0
          fi

          echo "‚ùå Failed to upsert account-level redirect rule with both variants"
          exit 1

        # Docs: Origin Rules via Rulesets API (phase http_request_origin).
        # https://developers.cloudflare.com/rules/origin-rules/create-api/