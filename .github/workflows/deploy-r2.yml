name: Deploy static site to Cloudflare R2 (apex + www)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # --- Required Secrets (set in GitHub: Settings ‚Üí Secrets and variables ‚Üí Actions) ---
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN:  ${{ secrets.CLOUDFLARE_API_TOKEN }}   # must allow: R2 Storage Write, DNS Write, Zone Transform/Origin Rules Write
      R2_ACCESS_KEY_ID:      ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY:  ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET:             ${{ secrets.R2_BUCKET }}              # e.g., site-interwebshack-com-<hash>
      R2_CUSTOM_DOMAIN:      "www.interwebshack.com"

      # --- Derived / Configurable ---
      ZONE_NAME: interwebshack.com
      SITE_DIR: site
      INDEX_OBJECT: index.html
      R2_ENDPOINT: https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # If you have a static-site build step, run it and output to $SITE_DIR.
      # - name: Build site
      #   run: <build> && mv dist "$SITE_DIR"

      - name: Sanity check local site folder
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Verifying site build output exists"
          echo "üìÅ SITE_DIR       = $SITE_DIR"
          echo "üìÑ INDEX_OBJECT   = $INDEX_OBJECT"

          if [[ ! -d "$SITE_DIR" ]]; then
            echo "‚ùå Expected directory ./$SITE_DIR but it does not exist."
            echo "   This usually means your build step didn't output to the correct folder."
            exit 1
          fi


          if [[ ! -f "$SITE_DIR/$INDEX_OBJECT" ]]; then
            echo "‚ùå Expected file ./$SITE_DIR/$INDEX_OBJECT but it was not found."
            echo "   Check your build command and output path."
            exit 1
          fi

          echo "‚úÖ Site directory and entry file verified"

      # --- Get zone_id for interwebshack.com ---
      - name: Resolve Cloudflare zone_id
        id: zone
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Fetching Cloudflare Zone ID for: $ZONE_NAME"

          # Make API request
          response=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}")

          # Split body and HTTP status
          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # If Cloudflare returned error
          if [[ "$http_status" -ne 200 ]]; then
            echo "‚ùå Error: Cloudflare API returned HTTP $http_status"
            echo "Response body:"
            echo "$body" | jq .
            exit 1
          fi

          success=$(echo "$body" | jq -r '.success')
          if [[ "$success" != "true" ]]; then
            echo "‚ùå Cloudflare returned success=false"
            echo "$body" | jq .
            exit 1
          fi

          zone_count=$(echo "$body" | jq '.result | length')
          if [[ "$zone_count" -eq 0 ]]; then
            echo "‚ùå No zones found matching: $ZONE_NAME"
            exit 1
          fi

          zone_id=$(echo "$body" | jq -r '.result[0].id')
          zone_name=$(echo "$body" | jq -r '.result[0].name')

          echo "‚úÖ Found zone: $zone_name"
          echo "üîë Zone ID: $zone_id"

          echo "zone_id=$zone_id" >> "$GITHUB_OUTPUT"

        # Docs: List Zones (get zone_id). 
        # https://developers.cloudflare.com/api/resources/zones/methods/list/

      # --- Ensure R2 bucket exists ---
      - name: Ensure R2 bucket (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "ü™£ Ensuring R2 bucket exists"
          echo "üìÇ Bucket name: $R2_BUCKET"
          echo "üë§ Account: $CLOUDFLARE_ACCOUNT_ID"

          # Attempt to create the bucket
          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${R2_BUCKET}\"}" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # 200 = created, 201 = created (depending on API), 409 = already exists
          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Bucket created successfully (or already existed and returned success)"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Bucket already exists ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to create bucket. Full Cloudflare response:"
          echo "$body" | jq || echo "$body"
          exit 1

        # Docs: Create R2 bucket (API). 
        # https://developers.cloudflare.com/api/resources/r2/subresources/buckets/methods/create/

      # --- Ensure R2 Custom Domain connected (makes bucket public over CDN) ---
      - name: Ensure R2 Custom Domain (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "üåê Ensuring R2 custom domain is attached to bucket"
          echo "ü™£ Bucket: ${R2_BUCKET}"
          echo "üîó Custom domain: ${R2_CUSTOM_DOMAIN}"
          echo "üë§ Account: ${CLOUDFLARE_ACCOUNT_ID}"
          echo "üß≠ Zone ID: ${{ steps.zone.outputs.zone_id }}"

          payload=$(jq -n \
            --arg domain "${R2_CUSTOM_DOMAIN}" \
            --arg zoneId "${{ steps.zone.outputs.zone_id }}" \
            '{domain: $domain, enabled: true, zoneId: $zoneId}')

          echo "üì¶ Request payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET}/domains/custom" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Custom domain attached to bucket successfully"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Custom domain already attached ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to attach custom domain to R2 bucket"
          echo "‚Äî Response body ‚Äî"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1

      # Docs: Public buckets & custom domains.
      # https://developers.cloudflare.com/r2/buckets/public-buckets/

      # --- Clean existing DNS records for managed hostnames (skip R2-managed) (idempotent & verbose) ---
      - name: Clean DNS records for root + www
        shell: bash
        env:
          ZONE_ID: ${{ steps.zone.outputs.zone_id }}
          MANAGED_HOSTNAMES: "interwebshack.com www.interwebshack.com"
          CF_DRY_RUN: "0"        # 1 = preview only, 0 = actually delete
          ALLOW_CRITICAL: "0"    # 1 = also delete NS/MX (NOT recommended)
        run: |
          set -euo pipefail

          echo "üßπ Preparing to clean DNS records in zone: $ZONE_ID"
          echo "üîß Managed hostnames: $MANAGED_HOSTNAMES"
          echo "üß™ Dry run mode: $CF_DRY_RUN (0=delete, 1=preview only)"
          echo "üö´ Skip records auto-managed by R2 (CNAME ‚Üí *.r2.dev)"
          echo "üö® Allow critical (MX/NS) deletion: $ALLOW_CRITICAL (0=no, 1=yes)"

          # Normalize ALLOW_CRITICAL into a number for jq (0 or 1)
          allow_critical_num=0
          [[ "${ALLOW_CRITICAL}" == "1" ]] && allow_critical_num=1

          # Helper: determines if a record is R2-managed (CNAME -> *.r2.dev)
          is_r2_managed() {
            # Args: TYPE NAME CONTENT
            local t="$1" n="$2" c="$3"
            if [[ "$t" == "CNAME" && "$c" =~ \.r2\.dev$ ]]; then
              return 0
            fi
            return 1
          }

          # Helper: delete all records for a given name
          delete_for_name() {
            local name="$1"
            echo ""
            echo "üîé Listing existing DNS records for: $name"

            resp=$(curl -sS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?name=${name}&per_page=1000")

            ok=$(echo "$resp" | jq -r '.success')
            if [[ "$ok" != "true" ]]; then
              echo "‚ùå Failed to list DNS records for ${name}"
              echo "$resp" | jq . 2>/dev/null || echo "$resp"
              exit 1
            fi

            count=$(echo "$resp" | jq '.result | length')
            echo "üìÉ Found ${count} record(s) for ${name}"

            if [[ "$count" -eq 0 ]]; then
              echo "‚úÖ Nothing to delete for ${name}"
              return 0
            fi

            echo "üßæ Current records:"
            echo "$resp" | jq -r '
              .result[] | [.id, .type, .name, (.content|tostring),
                            (if .proxied then "proxied" else "dns-only" end),
                            (."ttl"|tostring)]
              | @tsv
            ' | awk -F'\t' 'BEGIN{printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n","ID","TYPE","NAME","CONTENT","PROXY","TTL")} {printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n",$1,$2,$3,$4,$5,$6)}'

            # Build list of deletable IDs:
            # - exclude NS/MX unless allow_critical_num==1
            # - exclude CNAMEs to *.r2.dev (auto-managed by R2)
            mapfile -t ids < <(
              echo "$resp" | jq --argjson allow_crit ${allow_critical_num} -r '
                .result[]
                | select( ($allow_crit==1) or (.type!="NS" and .type!="MX") )
                | [.id, .type, .name, (.content|tostring)]
                | @tsv
              ' | while IFS=$'\t' read -r id type rname content; do
                    if is_r2_managed "$type" "$rname" "$content"; then
                      echo "üõ°Ô∏è  Skipping R2-managed record (will not delete): type=$type name=$rname content=$content" >&2
                      continue
                    fi
                    echo "$id"
                  done
            )

            if [[ "${#ids[@]}" -eq 0 ]]; then
              echo "üõ°Ô∏è No deletable records for ${name} after safety filters."
              return 0
            fi

            echo "üóëÔ∏è  Will delete ${#ids[@]} record(s) for ${name} (excluding R2-managed):"
            for id in "${ids[@]}"; do
              echo "  id=$id"
            done

            if [[ "$CF_DRY_RUN" == "1" ]]; then
              echo "üß™ Dry run enabled ‚Äî not deleting."
              return 0
            fi

            for id in "${ids[@]}"; do
              echo "‚û°Ô∏è  Deleting record id=${id} ..."
              del_resp=$(curl -sS -X DELETE \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${id}")

              del_ok=$(echo "$del_resp" | jq -r '.success')
              if [[ "$del_ok" == "true" ]]; then
                echo "   ‚úÖ Deleted id=${id}"
              else
                code=$(echo "$del_resp" | jq -r '.errors[0]?.code // empty')
                if [[ "$code" == "1052" ]]; then
                  echo "   üõ°Ô∏è  Skip: Record is auto-managed by Cloudflare (R2). Not deletable via DNS API."
                  continue
                fi
                echo "   ‚ùå Failed to delete id=${id}"
                echo "$del_resp" | jq . 2>/dev/null || echo "$del_resp"
                exit 1
              fi
            done

            echo "‚úÖ Completed deletions for ${name}"
          }

          for host in $MANAGED_HOSTNAMES; do
            delete_for_name "$host"
          done

          echo ""
          echo "üèÅ DNS cleanup complete for: $MANAGED_HOSTNAMES"


      # --- Ensure DNS records for apex exist (proxied placeholder) ---
      # ‚ö†Ô∏è IMPORTANT: WHY WE USE A PLACEHOLDER RECORD
      # Cloudflare will NOT apply Origin Rules unless a DNS record exists.
      # For R2 static hosting (without a Worker or Pages), the DNS record is just a "proxy trigger".
      #
      # ‚úÖ This A-record points to TEST-NET-1 (192.0.2.1) ‚Äî a ROUTABLE-NOWHERE IP.
      # ‚úÖ Traffic NEVER reaches this IP.
      # ‚úÖ Cloudflare proxy intercepts and rewrites to R2 using an Origin Rule.
      # ‚úÖ This record does NOT get replaced later ‚Äî it stays as a placeholder.
      # ‚ö†Ô∏è Do NOT change it to your server IP ‚Äî R2 has no IP origin.
      #
      # If you don't want placeholders, use a Worker fronting R2 or Cloudflare Pages instead.
      - name: Ensure DNS ‚Äî apex A (proxied placeholder)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"

          echo "üåê Ensuring DNS record exists for apex domain"
          echo "üìõ Domain: ${ZONE_NAME}"
          echo "üß≠ Zone ID: ${ZONE_ID}"
          echo "‚û°Ô∏è  Purpose: Placeholder A record (Cloudflare proxies request, Origin Rule sends to R2)"
          echo "üè∑Ô∏è  Placeholder IP: 192.0.2.1 (TEST-NET-1 ‚Äî safe, unused address)"

          payload=$(jq -n \
            --arg type "A" \
            --arg name "${ZONE_NAME}" \
            --arg content "192.0.2.1" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "üì¶ Payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° HTTP Status: $http_status"

          success=$(echo "$body" | jq -r '.success')

          if [[ "$success" == "true" ]]; then
            echo "‚úÖ Apex DNS placeholder created (proxy active for Origin Rule ‚Üí R2)"
            exit 0
          fi

          # Cloudflare error 81057 = record already exists
          if echo "$body" | jq -r '.errors[]?.code // empty' | grep -q "81057"; then
            echo "‚ÑπÔ∏è Placeholder record already exists ‚Äî OK (idempotent)"
            exit 0
          fi

          echo "‚ùå Failed to ensure apex placeholder record"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1
        # Docs: Create DNS record. 
        # https://developers.cloudflare.com/api/resources/dns/subresources/records/methods/create/


      # --- Ensure DNS ‚Äî www CNAME to apex (proxied placeholder) ---
      # If R2 custom-domain already created a www CNAME to *.r2.dev, we KEEP it and skip.
      # Otherwise we ensure www -> CNAME apex (proxied) so Origin Rules can attach.
      - name: Ensure DNS ‚Äî www CNAME (respect R2-managed)
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"
          HOST="www"
          FQDN="${HOST}.${ZONE_NAME}"
          TARGET="${ZONE_NAME}"

          echo "üåê Ensuring DNS CNAME for: ${FQDN}"
          echo "üéØ Desired target: ${TARGET}"
          echo "‚õÖ Desired mode: proxied"
          echo "üß≠ Zone ID: ${ZONE_ID}"

          # 1) Look up existing CNAME(s) for www
          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=CNAME&name=${FQDN}&per_page=1000")

          list_ok=$(echo "$list_resp" | jq -r '.success')
          if [[ "$list_ok" != "true" ]]; then
            echo "‚ùå Failed to list existing CNAMEs for ${FQDN}"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            exit 1
          fi

          count=$(echo "$list_resp" | jq '.result | length')
          echo "üîé Existing CNAME count for ${FQDN}: $count"

          if [[ "$count" -gt 0 ]]; then
            # There is at least one CNAME
            # Check if any is R2-managed (content ends with .r2.dev)
            r2_managed=$(echo "$list_resp" | jq -r '.result[]?.content | select(test("\\.r2\\.dev$")) | . ' | wc -l | tr -d ' ')
            if [[ "$r2_managed" -gt 0 ]]; then
              echo "üõ°Ô∏è Found R2-managed CNAME (‚Üí *.r2.dev). Keeping it and skipping changes."
              echo "‚úÖ www already routed by R2 custom-domain. No action needed."
              exit 0
            fi

            # Not R2-managed. See if one already matches apex + proxied=true
            matching=$(echo "$list_resp" | jq --arg tgt "$TARGET" -r '
              .result[] | select(.content == $tgt and .proxied == true) | .id
            ')
            if [[ -n "$matching" ]]; then
              echo "‚ÑπÔ∏è CNAME already points to apex and is proxied (id=$matching)."
              echo "‚úÖ No change required."
              exit 0
            fi

            # Otherwise, PATCH the first record to desired state
            record_id=$(echo "$list_resp" | jq -r '.result[0].id')
            echo "üõ†Ô∏è Updating existing CNAME id=${record_id} to target=${TARGET} (proxied=true)"

            patch_payload=$(jq -n \
              --arg type "CNAME" \
              --arg name "${HOST}" \
              --arg content "${TARGET}" \
              --argjson proxied true \
              '{type:$type,name:$name,content:$content,proxied:$proxied}')

            echo "üì¶ PATCH payload:"
            echo "$patch_payload" | jq .

            patch_resp=$(curl -sS -w "\n%{http_code}" -X PUT \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${record_id}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$patch_payload" || true)

            patch_body=$(echo "$patch_resp" | sed '$d')
            patch_status=$(echo "$patch_resp" | tail -n1)

            echo "üì° PATCH HTTP Status: $patch_status"
            if [[ "$(echo "$patch_body" | jq -r '.success')" == "true" ]]; then
              echo "‚úÖ Updated www CNAME successfully."
              exit 0
            else
              echo "‚ùå Failed to update existing CNAME"
              echo "$patch_body" | jq . 2>/dev/null || echo "$patch_body"
              exit 1
            fi
          fi

          # 2) No existing CNAME: create desired one (unless R2 will manage it)
          echo "üÜï Creating new CNAME: ${FQDN} ‚Üí ${TARGET} (proxied=true)"

          post_payload=$(jq -n \
            --arg type "CNAME" \
            --arg name "${HOST}" \
            --arg content "${TARGET}" \
            --argjson proxied true \
            '{type:$type,name:$name,content:$content,proxied:$proxied}')

          echo "üì¶ POST payload:"
          echo "$post_payload" | jq .

          post_resp=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$post_payload" || true)

          post_body=$(echo "$post_resp" | sed '$d')
          post_status=$(echo "$post_resp" | tail -n1)

          echo "üì° POST HTTP Status: $post_status"
          if [[ "$(echo "$post_body" | jq -r '.success')" == "true" ]]; then
            echo "‚úÖ Created www CNAME (proxied) successfully."
            exit 0
          fi

          # Handle "already exists" gracefully (race or pre-existing)
          if echo "$post_body" | jq -r '.errors[]?.code // empty' | grep -q "81053"; then
            echo "‚ÑπÔ∏è Record already exists (81053). This is OK; step is idempotent."
            exit 0
          fi

          echo "‚ùå Failed to create www CNAME"
          echo "$post_body" | jq . 2>/dev/null || echo "$post_body"
          exit 1
        # Docs: Create DNS record. 
        # https://developers.cloudflare.com/api/resources/dns/subresources/records/methods/create/

      # --- Ensure an Origin Rules ruleset exists; then add rules to route apex + www to R2 ---
      # Cloudflare Engine Logic:
      #   DNS record -> CF Proxy -> Origin Rule -> R2 bucket
      #
      # Why we need this:
      #  ‚Ä¢ R2 buckets have no IP (you can't point DNS directly)
      #  ‚Ä¢ DNS just "activates" the proxy
      #  ‚Ä¢ Origin Rules change the "origin" to the R2 bucket hostname
      #
      # This step ensures the `http_request_origin` phase ruleset exists.
      #   - If it exists, we reuse it (idempotent)
      #   - If it doesn't exist, we create it
      #
      # Phase explanation:
      #   "http_request_origin" phase runs when Cloudflare chooses the origin to fetch from.
      #   It will tell Cloudflare: "instead of placeholder IP, talk to R2"
      #
      - name: Ensure Origin Rules ruleset exists (http_request_origin)
        id: ruleset
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"

          echo "üö¶ Ensuring Origin Rules ruleset exists for zone"
          echo "üß≠ Zone ID: $ZONE_ID"
          echo "üîÅ Purpose: Create or fetch the 'http_request_origin' ruleset (used to route apex+www ‚Üí R2)"

          echo "üîé Checking for existing ruleset in http_request_origin phase..."

          list_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets")

          list_ok=$(echo "$list_resp" | jq -r '.success // empty')

          if [[ "$list_ok" != "true" ]]; then
            echo "‚ùå Failed to list rulesets"
            echo "$list_resp" | jq . 2>/dev/null || echo "$list_resp"
            exit 1
          fi

          rid=$(echo "$list_resp" | jq -r '.result[] | select(.phase=="http_request_origin") | .id // empty')

          if [[ -n "$rid" ]]; then
            echo "‚úÖ Found existing http_request_origin ruleset"
            echo "üÜî Ruleset ID: $rid"
          else
            echo "‚ö†Ô∏è No existing http_request_origin ruleset found"
            echo "‚ûï Creating new Origin Rules ruleset for this zone..."

            create_payload='{
              "name": "Origin Rules ruleset",
              "description": "Zone-level ruleset for origin overrides (R2 static hosting)",
              "kind": "zone",
              "phase": "http_request_origin",
              "rules": []
            }'

            echo "üì¶ Payload:"
            echo "$create_payload" | jq .

            create_resp=$(curl -sS -X POST \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "$create_payload")

            create_ok=$(echo "$create_resp" | jq -r '.success // empty')

            if [[ "$create_ok" != "true" ]]; then
              echo "‚ùå Failed to create Origin Rules ruleset"
              echo "$create_resp" | jq . 2>/dev/null || echo "$create_resp"
              exit 1
            fi

            rid=$(echo "$create_resp" | jq -r '.result.id')
            echo "‚úÖ Created new Origin Rules ruleset"
            echo "üÜî Ruleset ID: $rid"
          fi

          echo "üì§ Exporting ruleset_id to GitHub outputs"
          echo "ruleset_id=$rid" >> "$GITHUB_OUTPUT"

          echo "üèÅ Origin Rules ruleset ensure step complete ‚Äî ruleset is ready."
          echo "   Next step will insert/update rule to route apex + www ‚Üí R2"

      # --- Upsert Origin Rule for apex + www ‚Üí R2 custom domain (idempotent, verbose, safe) ---
      # This ensures a single "route" rule exists that rewrites origin for:
      #   interwebshack.com and www.interwebshack.com
      # to your R2 custom domain (host header + origin override).
      #
      # Why:
      #  ‚Ä¢ DNS placeholder only enables proxy; the real routing happens here.
      #  ‚Ä¢ This rule tells Cloudflare to fetch from R2 instead of the placeholder.
      #
      - name: Upsert Origin Rule for apex + www ‚Üí R2 custom domain
        shell: bash
        run: |
          set -euo pipefail

          ZONE_ID="${{ steps.zone.outputs.zone_id }}"
          RULESET_ID="${{ steps.ruleset.outputs.ruleset_id }}"
          TARGET="${R2_CUSTOM_DOMAIN}"

          echo "üö¶ Upserting Origin Rule (route) in http_request_origin ruleset"
          echo "üß≠ Zone ID: ${ZONE_ID}"
          echo "üÜî Ruleset ID: ${RULESET_ID}"
          echo "üéØ R2 custom domain (target host): ${TARGET}"

          # -------- Input validation --------
          if [[ -z "${ZONE_ID}" || -z "${RULESET_ID}" || -z "${TARGET}" ]]; then
            echo "‚ùå Missing required inputs. ZONE_ID, RULESET_ID, and R2_CUSTOM_DOMAIN must be set."
            exit 1
          fi

          if ! [[ "${TARGET}" =~ ^[a-z0-9.-]+$ ]]; then
            echo "‚ùå R2_CUSTOM_DOMAIN looks invalid: '${TARGET}'"
            echo "   Must be a DNS hostname (lowercase letters, digits, dots, dashes)."
            exit 1
          fi

          # Expression matching apex + www
          EXPR='(http.host eq "interwebshack.com") or (http.host eq "www.interwebshack.com")'
          RULE_REF="route_r2_interwebshack"
          RULE_DESC="Route apex+www to R2 custom domain"

          # Desired rule object for comparison
          desired_rule=$(jq -n \
            --arg ref "${RULE_REF}" \
            --arg desc "${RULE_DESC}" \
            --arg expression "${EXPR}" \
            --arg host "${TARGET}" \
            '{
              ref: $ref,
              description: $desc,
              expression: $expression,
              action: "route",
              action_parameters: {
                host_header: $host,
                origin: { host: $host }
              }
            }')

          echo "üß© Desired rule:"
          echo "$desired_rule" | jq .

          # -------- Fetch current ruleset (to inspect and merge) --------
          echo "üîé Fetching current ruleset to check existing rules‚Ä¶"
          get_resp=$(curl -sS \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets/${RULESET_ID}")

          get_ok=$(echo "$get_resp" | jq -r '.success // empty')
          if [[ "$get_ok" != "true" ]]; then
            echo "‚ùå Failed to fetch ruleset"
            echo "$get_resp" | jq . 2>/dev/null || echo "$get_resp"
            echo "üõ† Fix: Ensure token has Zone ‚Üí Origin Rules / Transform Rules: Edit and zone access."
            exit 1
          fi

          # Extract current rules array (or empty)
          current_rules=$(echo "$get_resp" | jq '.result.rules // []')
          current_count=$(echo "$current_rules" | jq 'length')
          echo "üìö Rules currently in ruleset: $current_count"

          # Find any existing rule with our ref
          existing_rule=$(echo "$current_rules" | jq --arg ref "$RULE_REF" '
            .[] | select(.ref == $ref)
          ')

          if [[ -n "$existing_rule" ]]; then
            echo "‚ÑπÔ∏è Found existing rule with ref=$RULE_REF. Checking if identical‚Ä¶"

            # Build a minimal comparable view (action, expr, host_header, origin.host)
            want_min=$(echo "$desired_rule" | jq '{action, expression, action_parameters: {host_header: .action_parameters.host_header, origin: {host: .action_parameters.origin.host}}}')
            have_min=$(echo "$existing_rule" | jq '{action, expression, action_parameters: {host_header: .action_parameters.host_header, origin: {host: .action_parameters.origin.host}}}')

            if diff=$(diff -u <(echo "$have_min") <(echo "$want_min")) ; then
              echo "‚úÖ Existing rule is identical. No update needed."
              exit 0
            else
              echo "‚úèÔ∏è Existing rule differs from desired; will update."
              echo "üîç Diff (have ‚Üí want):"
              diff -u <(echo "$have_min") <(echo "$want_min") || true
            fi
          else
            echo "‚ûï No existing rule with ref=$RULE_REF; will add it."
          fi

          # -------- Build new rules list: remove old ref (if any) and append desired rule --------
          new_rules=$(jq --arg ref "$RULE_REF" --argjson desired "$desired_rule" -n \
            --argjson current "$current_rules" '
              ($current | map(select(.ref != $ref))) + [ $desired ]
            ')

          new_count=$(echo "$new_rules" | jq 'length')
          echo "üßÆ Rules after merge: $new_count (was $current_count)"
          echo "üì¶ PUT payload (rules only):"
          echo "$new_rules" | jq .

          # -------- PUT update (only when needed) --------
          put_payload=$(jq -n --argjson rules "$new_rules" '{ rules: $rules }')

          put_resp=$(curl -sS -w "\n%{http_code}" -X PUT \
            "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/rulesets/${RULESET_ID}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$put_payload" || true)

          put_body=$(echo "$put_resp" | sed '$d')
          put_code=$(echo "$put_resp" | tail -n1)

          echo "üì° PUT HTTP Status: $put_code"

          if [[ "$(echo "$put_body" | jq -r '.success // empty')" == "true" ]]; then
            echo "‚úÖ Upserted Origin Rule successfully."
            # Print a brief summary of the rule now present
            echo "$put_body" | jq '
              .result.rules[]
              | select(.ref=="'"$RULE_REF"'")
              | {ref, action, expression, action_parameters: {host_header: .action_parameters.host_header, origin: {host: .action_parameters.origin.host}}}
            '
            exit 0
          fi

          # Handle common errors more gracefully
          err_code=$(echo "$put_body" | jq -r '.errors[0]?.code // empty')
          err_msg=$(echo "$put_body" | jq -r '.errors[0]?.message // empty')

          echo "‚ùå Failed to upsert Origin Rule"
          echo "$put_body" | jq . 2>/dev/null || echo "$put_body"

          echo "üõ† Hints:"
          echo " ‚Ä¢ Confirm token has: Zone ‚Üí Origin Rules / Transform Rules: Edit"
          echo " ‚Ä¢ Confirm the ruleset exists and RULESET_ID is correct"
          echo " ‚Ä¢ Ensure your payload is valid (hostnames, expression syntax)"
          echo " ‚Ä¢ If other rules conflict, Cloudflare may reject; inspect existing rules"
          echo " ‚Ä¢ You can try a minimal payload with only this rule if merge fails"

          exit 1

        # Docs: Origin Rules via Rulesets API (phase http_request_origin).
        # https://developers.cloudflare.com/rules/origin-rules/create-api/
