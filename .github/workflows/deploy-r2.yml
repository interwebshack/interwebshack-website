name: Deploy static site to Cloudflare R2 (apex + www)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # --- Required Secrets (set in GitHub: Settings ‚Üí Secrets and variables ‚Üí Actions) ---
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN:  ${{ secrets.CLOUDFLARE_API_TOKEN }}   # must allow: R2 Storage Write, DNS Write, Zone Transform/Origin Rules Write
      R2_ACCESS_KEY_ID:      ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY:  ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET:             ${{ secrets.R2_BUCKET }}              # e.g., site-interwebshack-com-<hash>
      R2_CUSTOM_DOMAIN:      "www.interwebshack.com"

      # --- Derived / Configurable ---
      ZONE_NAME: interwebshack.com
      SITE_DIR: site
      INDEX_OBJECT: index.html
      R2_ENDPOINT: https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # If you have a static-site build step, run it and output to $SITE_DIR.
      # - name: Build site
      #   run: <build> && mv dist "$SITE_DIR"

      - name: Sanity check local site folder
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Verifying site build output exists"
          echo "üìÅ SITE_DIR       = $SITE_DIR"
          echo "üìÑ INDEX_OBJECT   = $INDEX_OBJECT"

          if [[ ! -d "$SITE_DIR" ]]; then
            echo "‚ùå Expected directory ./$SITE_DIR but it does not exist."
            echo "   This usually means your build step didn't output to the correct folder."
            exit 1
          fi


          if [[ ! -f "$SITE_DIR/$INDEX_OBJECT" ]]; then
            echo "‚ùå Expected file ./$SITE_DIR/$INDEX_OBJECT but it was not found."
            echo "   Check your build command and output path."
            exit 1
          fi

          echo "‚úÖ Site directory and entry file verified"

      # --- Get zone_id for interwebshack.com ---
      - name: Resolve Cloudflare zone_id
        id: zone
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Fetching Cloudflare Zone ID for: $ZONE_NAME"

          # Make API request
          response=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}")

          # Split body and HTTP status
          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # If Cloudflare returned error
          if [[ "$http_status" -ne 200 ]]; then
            echo "‚ùå Error: Cloudflare API returned HTTP $http_status"
            echo "Response body:"
            echo "$body" | jq .
            exit 1
          fi

          success=$(echo "$body" | jq -r '.success')
          if [[ "$success" != "true" ]]; then
            echo "‚ùå Cloudflare returned success=false"
            echo "$body" | jq .
            exit 1
          fi

          zone_count=$(echo "$body" | jq '.result | length')
          if [[ "$zone_count" -eq 0 ]]; then
            echo "‚ùå No zones found matching: $ZONE_NAME"
            exit 1
          fi

          zone_id=$(echo "$body" | jq -r '.result[0].id')
          zone_name=$(echo "$body" | jq -r '.result[0].name')

          echo "‚úÖ Found zone: $zone_name"
          echo "üîë Zone ID: $zone_id"

          echo "zone_id=$zone_id" >> "$GITHUB_OUTPUT"

        # Docs: List Zones (get zone_id). 
        # https://developers.cloudflare.com/api/resources/zones/methods/list/

      # --- Ensure R2 bucket exists ---
      - name: Ensure R2 bucket (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "ü™£ Ensuring R2 bucket exists"
          echo "üìÇ Bucket name: $R2_BUCKET"
          echo "üë§ Account: $CLOUDFLARE_ACCOUNT_ID"

          # Attempt to create the bucket
          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"${R2_BUCKET}\"}" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          # 200 = created, 201 = created (depending on API), 409 = already exists
          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Bucket created successfully (or already existed and returned success)"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Bucket already exists ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to create bucket. Full Cloudflare response:"
          echo "$body" | jq || echo "$body"
          exit 1

        # Docs: Create R2 bucket (API). 
        # https://developers.cloudflare.com/api/resources/r2/subresources/buckets/methods/create/

      # --- Ensure R2 Custom Domain connected (makes bucket public over CDN) ---
      - name: Ensure R2 Custom Domain (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          echo "üåê Ensuring R2 custom domain is attached to bucket"
          echo "ü™£ Bucket: ${R2_BUCKET}"
          echo "üîó Custom domain: ${R2_CUSTOM_DOMAIN}"
          echo "üë§ Account: ${CLOUDFLARE_ACCOUNT_ID}"
          echo "üß≠ Zone ID: ${{ steps.zone.outputs.zone_id }}"

          payload=$(jq -n \
            --arg domain "${R2_CUSTOM_DOMAIN}" \
            --arg zoneId "${{ steps.zone.outputs.zone_id }}" \
            '{domain: $domain, enabled: true, zoneId: $zoneId}')

          echo "üì¶ Request payload:"
          echo "$payload" | jq .

          response=$(curl -sS -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/r2/buckets/${R2_BUCKET}/domains/custom" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$payload" || true)

          body=$(echo "$response" | sed '$d')
          http_status=$(echo "$response" | tail -n1)

          echo "üì° Cloudflare API HTTP status: $http_status"

          if [[ "$http_status" == "200" || "$http_status" == "201" ]]; then
            echo "‚úÖ Custom domain attached to bucket successfully"
            exit 0
          fi

          if [[ "$http_status" == "409" ]]; then
            echo "‚ÑπÔ∏è Custom domain already attached ‚Äî continuing"
            exit 0
          fi

          echo "‚ùå Failed to attach custom domain to R2 bucket"
          echo "‚Äî Response body ‚Äî"
          echo "$body" | jq . 2>/dev/null || echo "$body"
          exit 1

      # Docs: Public buckets & custom domains.
      # https://developers.cloudflare.com/r2/buckets/public-buckets/

      # --- Clean existing DNS records for managed hostnames (idempotent & verbose) ---
      - name: Clean DNS records for root + www
        shell: bash
        env:
          ZONE_ID: ${{ steps.zone.outputs.zone_id }}
          MANAGED_HOSTNAMES: "interwebshack.com www.interwebshack.com"
          # Set to 1 to actually delete; set to 0 for a dry run preview
          CF_DRY_RUN: "0"
          # Set to 1 if you ALSO want to delete MX/NS (NOT recommended)
          ALLOW_CRITICAL: "0"
        run: |
          set -euo pipefail

          echo "üßπ Preparing to clean DNS records in zone: $ZONE_ID"
          echo "üîß Managed hostnames: $MANAGED_HOSTNAMES"
          echo "üß™ Dry run mode: $CF_DRY_RUN (0=delete, 1=preview only)"
          echo "üö® Allow critical (MX/NS) deletion: $ALLOW_CRITICAL (0=no, 1=yes)"

          # Helper: delete all records for a given name
          delete_for_name() {
            local name="$1"
            echo ""
            echo "üîé Listing existing DNS records for: $name"

            # Get up to 1000 records for this exact name
            resp=$(curl -sS -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?name=${name}&per_page=1000")

            ok=$(echo "$resp" | jq -r '.success')
            if [[ "$ok" != "true" ]]; then
              echo "‚ùå Failed to list DNS records for ${name}"
              echo "$resp" | jq . 2>/dev/null || echo "$resp"
              exit 1
            fi

            count=$(echo "$resp" | jq '.result | length')
            echo "üìÉ Found ${count} record(s) for ${name}"

            if [[ "$count" -eq 0 ]]; then
              echo "‚úÖ Nothing to delete for ${name}"
              return 0
            fi

            # Show a table of what we plan to delete
            echo "üßæ Current records:"
            echo "$resp" | jq -r '
              .result[] | [.id, .type, .name, (.content|tostring), (if .proxied then "proxied" else "dns-only" end), (."ttl"|tostring)]
              | @tsv
            ' | awk -F'\t' 'BEGIN{printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n","ID","TYPE","NAME","CONTENT","PROXY","TTL")} {printf("  %-37s %-6s %-35s %-40s %-10s %-6s\n",$1,$2,$3,$4,$5,$6)}'

            # Filter which records to delete
            if [[ "$ALLOW_CRITICAL" == "1" ]]; then
              filter='.result[]'
            else
              # Exclude NS/MX by default (safer)
              filter='.result[] | select(.type != "NS" and .type != "MX")'
            fi

            # Collect IDs to delete
            mapfile -t ids < <(echo "$resp" | jq -r "${filter} | .id")

            if [[ "${#ids[@]}" -eq 0 ]]; then
              echo "üõ°Ô∏è No deletable records found for ${name} with current safety filters."
              return 0
            fi

            echo "üóëÔ∏è  Will delete ${#ids[@]} record(s) for ${name}:"
            echo "$resp" | jq -r "${filter} | [ .id, .type, .name, (.content|tostring) ] | @tsv" \
              | awk -F'\t' '{printf("  id=%s type=%-5s name=%-35s content=%s\n",$1,$2,$3,$4)}'

            if [[ "$CF_DRY_RUN" == "1" ]]; then
              echo "üß™ Dry run enabled ‚Äî not deleting."
              return 0
            fi

            # Delete each record verbosely
            for id in "${ids[@]}"; do
              echo "‚û°Ô∏è  Deleting record id=${id} ..."
              del_resp=$(curl -sS -X DELETE \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${id}")

              del_ok=$(echo "$del_resp" | jq -r '.success')
              if [[ "$del_ok" == "true" ]]; then
                echo "   ‚úÖ Deleted id=${id}"
              else
                echo "   ‚ùå Failed to delete id=${id}"
                echo "$del_resp" | jq . 2>/dev/null || echo "$del_resp"
                exit 1
              fi
            done

            echo "‚úÖ Completed deletions for ${name}"
          }

          # Loop over requested hostnames
          for host in $MANAGED_HOSTNAMES; do
            delete_for_name "$host"
          done

          echo ""
          echo "üèÅ DNS cleanup complete for: $MANAGED_HOSTNAMES"
